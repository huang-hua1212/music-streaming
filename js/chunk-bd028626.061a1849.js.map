{"version":3,"sources":["webpack:///./node_modules/@vue-leaflet/vue-leaflet/dist/vue-leaflet.esm.js","webpack:///./node_modules/regenerator-runtime/runtime.js","webpack:///./src/components/Map.vue","webpack:///./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js","webpack:///./src/components/Map.vue?57bc"],"names":["debounce","fn","time","timeout","args","context","this","clearTimeout","setTimeout","apply","capitalizeFirstLetter","string","charAt","toUpperCase","slice","propsBinder","methods","leafletElement","props","key","setMethodName","newVal","oldVal","remapEvents","contextAttrs","result","attrName","startsWith","eventName","toLocaleLowerCase","resetWebpackIcon","async","Icon","modules","Promise","all","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","default","iconUrl","shadowUrl","provideLeafletWrapper","methodName","wrapped","console","warn","wrapper","value","updateLeafletWrapper","leafletMethod","WINDOW_OR_GLOBAL","self","global","undefined","GLOBAL_LEAFLET_OPT","options","type","Object","setup","props$1","pane","String","attribution","name","custom","layerType","visible","Boolean","setup$1","leafletRef","addLayer","removeLayer","componentOptions","componentMethods","addThisLayer","leafletObject","removeThisLayer","val","old","attributionControl","$parent","removeAttribution","addAttribution","isVisible","bindPopup","bindTooltip","tooltip","getTooltip","unbindTooltip","popup","getPopup","unbindPopup","emit","props$2","interactive","bubblingMouseEvents","props$3","stroke","color","weight","Number","opacity","lineCap","lineJoin","dashArray","dashOffset","fill","fillColor","fillOpacity","fillRule","className","props$4","latLng","Array","radius","props$6","position","setup$6","setPosition","remove","render$1","slots","ref","props$b","props$e","zIndex","tileSize","noWrap","minZoom","maxZoom","setup$e","layerOptions","layerMethods","props$f","iconSize","iconAnchor","popupAnchor","tooltipAnchor","shadowRetinaUrl","shadowSize","shadowAnchor","bgPos","script$d","emits","center","bounds","maxBounds","zoom","paddingBottomRight","paddingTopLeft","padding","worldCopyJump","crs","maxBoundsViscosity","inertia","inertiaDeceleration","inertiaMaxSpeed","easeLinearity","zoomAnimation","zoomAnimationThreshold","fadeAnimation","markerZoomAnimation","noBlockingAnimations","useGlobalLeaflet","root","blueprint","ready","layersToAdd","layersInControl","registerControl","registerLayerControl","eventHandlers","getZoom","getCenter","getBounds","e","layer","find","l","updateVisibleProp","L","map","CRS","latLngBounds","DomEvent","beforeMapMount","error","message","optionsCrs","EPSG3857","layerControl","push","exist","_leaflet_id","filter","lControlLayer","forEach","lControl","addControl","setZoom","animate","prevBounds","fitBounds","newBounds","isValid","oldBounds","lastSetBounds","boundsChanged","equals","fitBoundsOptions","newCenter","oldCenter","lastSetCenter","lat","lng","panTo","listeners","attrs","on","moveEndHandler","overlayAddHandler","overlayRemoveHandler","style","width","height","$slots","props$i","latLngs","smoothFactor","noClip","props$j","props$k","content","props$n","tms","subdomains","detectRetina","url","setup$m","gridLayerOptions","gridLayerMethods","script$j","tileLayer","runtime","exports","Op","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","define","obj","defineProperty","enumerable","configurable","writable","err","wrap","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","create","Context","_invoke","makeInvokeMethod","tryCatch","arg","call","GenStateSuspendedStart","GenStateSuspendedYield","GenStateExecuting","GenStateCompleted","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","method","AsyncIterator","PromiseImpl","invoke","resolve","reject","record","__await","then","unwrapped","previousPromise","enqueue","callInvokeWithMethodAndArg","state","Error","doneResult","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","done","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","length","i","displayName","isGeneratorFunction","genFun","ctor","constructor","mark","setPrototypeOf","__proto__","awrap","iter","keys","object","reverse","pop","skipTempReset","prev","stop","rootEntry","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","module","regeneratorRuntime","accidentalStrictMode","globalThis","Function","_createElementVNode","for","id","_createVNode","_component_l_map","$data","_component_l_tile_layer","class","onClick","$options","_hoisted_1","$event","onChange","_ctx","_hoisted_2","_hoisted_3","_hoisted_4","_hoisted_5","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","arguments","components","LMap","LTileLayer","data","is_showBoundary","created","getCityBoundaryjson","mounted","beforeMount","mapIsReady","makeCityBoundary","axios","get","res","geojson","features","__exports__","render"],"mappings":"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","file":"js/chunk-bd028626.061a1849.js","sourcesContent":["import { watch, ref, provide, h, inject, onUnmounted, onBeforeUnmount, onMounted, nextTick, render as render$3, reactive, computed } from 'vue';\n\nconst debounce = (fn, time) => {\n  let timeout;\n\n  return function (...args) {\n    const context = this;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      fn.apply(context, args);\n      timeout = null;\n    }, time);\n  };\n};\n\nconst capitalizeFirstLetter = (string) => {\n  if (!string || typeof string.charAt !== \"function\") {\n    return string;\n  }\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\nconst propsBinder = (methods, leafletElement, props) => {\n  for (const key in props) {\n    const setMethodName = \"set\" + capitalizeFirstLetter(key);\n    if (methods[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal, oldVal) => {\n          methods[setMethodName](newVal, oldVal);\n        }\n      );\n    } else if (leafletElement[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal) => {\n          leafletElement[setMethodName](newVal);\n        }\n      );\n    }\n  }\n};\n\nconst remapEvents = (contextAttrs) => {\n  const result = {};\n  for (const attrName in contextAttrs) {\n    if (\n      attrName.startsWith(\"on\") &&\n      !attrName.startsWith(\"onUpdate\") &&\n      attrName !== \"onReady\"\n    ) {\n      const eventName = attrName.slice(2).toLocaleLowerCase();\n      result[eventName] = contextAttrs[attrName];\n    }\n  }\n  return result;\n};\n\nconst resetWebpackIcon = async (Icon) => {\n  const modules = await Promise.all([\n    import('leaflet/dist/images/marker-icon-2x.png'),\n    import('leaflet/dist/images/marker-icon.png'),\n    import('leaflet/dist/images/marker-shadow.png'),\n  ]);\n\n  delete Icon.Default.prototype._getIconUrl;\n\n  Icon.Default.mergeOptions({\n    iconRetinaUrl: modules[0].default,\n    iconUrl: modules[1].default,\n    shadowUrl: modules[2].default,\n  });\n};\n\n/**\n * Wraps a placeholder function and provides it with the given name.\n * The wrapper can later be updated with {@link updateLeafletWrapper}\n * to provide a different function.\n *\n * @param {String} methodName Key used to provide the wrapper function\n */\nconst provideLeafletWrapper = (methodName) => {\n  const wrapped = ref(() =>\n    console.warn(`Method ${methodName} has been invoked without being replaced`)\n  );\n  const wrapper = (...args) => wrapped.value(...args);\n  // eslint-disable-next-line vue/no-ref-as-operand\n  wrapper.wrapped = wrapped;\n  provide(methodName, wrapper);\n\n  return wrapper;\n};\n\n/**\n * Change the function that will be executed when an injected Leaflet wrapper\n * is invoked.\n *\n * @param {*} wrapper Provided wrapper whose wrapped function is to be updated\n * @param {function} leafletMethod New method to be wrapped by the wrapper\n */\nconst updateLeafletWrapper = (wrapper, leafletMethod) =>\n  (wrapper.wrapped.value = leafletMethod);\n\nconst WINDOW_OR_GLOBAL =\n  (typeof self === \"object\" && self.self === self && self) ||\n  (typeof global === \"object\" && global.global === global && global) ||\n  undefined;\n\nconst GLOBAL_LEAFLET_OPT = \"useGlobalLeaflet\";\n\nconst props = {\n  options: {\n    type: Object,\n    default: () => ({}),\n  },\n};\n\nconst setup = (props) => {\n  return { options: props.options, methods: {} };\n};\n\nconst props$1 = {\n  ...props,\n  pane: {\n    type: String,\n    default: \"overlayPane\",\n  },\n  attribution: {\n    type: String,\n    default: null,\n  },\n  name: {\n    type: String,\n    custom: true,\n    default: undefined,\n  },\n  layerType: {\n    type: String,\n    custom: true,\n    default: undefined,\n  },\n  visible: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n};\n\nconst setup$1 = (props, leafletRef, context) => {\n  const addLayer = inject(\"addLayer\");\n  const removeLayer = inject(\"removeLayer\");\n  const {\n    options: componentOptions,\n    methods: componentMethods,\n  } = setup(props);\n\n  const options = {\n    ...componentOptions,\n    attribution: props.attribution,\n    pane: props.pane,\n  };\n\n  const addThisLayer = () => addLayer({ leafletObject: leafletRef.value });\n  const removeThisLayer = () =>\n    removeLayer({ leafletObject: leafletRef.value });\n\n  const methods = {\n    ...componentMethods,\n    setAttribution(val, old) {\n      const attributionControl = this.$parent.leafletObject.attributionControl;\n      attributionControl.removeAttribution(old).addAttribution(val);\n    },\n    setName() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setLayerType() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setVisible(isVisible) {\n      if (leafletRef.value) {\n        if (isVisible) {\n          addThisLayer();\n        } else {\n          removeThisLayer();\n        }\n      }\n    },\n    bindPopup({ leafletObject }) {\n      leafletRef.value.bindPopup(leafletObject);\n    },\n    bindTooltip({ leafletObject }) {\n      leafletRef.value.bindTooltip(leafletObject);\n    },\n    unbindTooltip() {\n      const tooltip = leafletRef.value ? leafletRef.value.getTooltip() : null;\n      if (tooltip) {\n        tooltip.unbindTooltip();\n      }\n    },\n    unbindPopup() {\n      const popup = leafletRef.value ? leafletRef.value.getPopup() : null;\n      if (popup) {\n        popup.unbindPopup();\n      }\n    },\n    updateVisibleProp(value) {\n      /**\n       * Triggers when the visible prop needs to be updated\n       * @type {boolean}\n       * @property {boolean} value - value of the visible property\n       */\n      context.emit(\"update:visible\", value);\n    },\n  };\n\n  provide(\"bindPopup\", methods.bindPopup);\n  provide(\"bindTooltip\", methods.bindTooltip);\n  provide(\"unbindTooltip\", methods.unbindTooltip);\n  provide(\"unbindPopup\", methods.unbindPopup);\n\n  onUnmounted(() => {\n    methods.unbindPopup();\n    methods.unbindTooltip();\n    removeThisLayer();\n  });\n\n  return { options, methods };\n};\n\nconst render = (ready, slots) => {\n  if (ready && slots.default) {\n    return h(\"div\", { style: { display: \"none\" } }, slots.default());\n  }\n};\n\nconst props$2 = {\n  ...props,\n  interactive: {\n    type: Boolean,\n    default: true,\n  },\n  bubblingMouseEvents: {\n    type: Boolean,\n    default: true,\n  },\n};\n\nconst setup$2 = (props) => {\n  const { options: componentOptions, methods } = setup(props);\n  const options = {\n    ...componentOptions,\n    interactive: props.interactive,\n    bubblingMouseEvents: props.bubblingMouseEvents,\n  };\n\n  return { options, methods };\n};\n\nconst props$3 = {\n  ...props$1,\n  ...props$2,\n  stroke: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n  color: {\n    type: String,\n    custom: true,\n    default: \"#3388ff\",\n  },\n  weight: {\n    type: Number,\n    custom: true,\n    default: 3,\n  },\n  opacity: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  lineCap: {\n    type: String,\n    custom: true,\n    default: \"round\",\n  },\n  lineJoin: {\n    type: String,\n    custom: true,\n    default: \"round\",\n  },\n  dashArray: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  dashOffset: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  fill: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n  fillColor: {\n    type: String,\n    custom: true,\n    default: \"#3388ff\",\n  },\n  fillOpacity: {\n    type: Number,\n    custom: true,\n    default: 0.2,\n  },\n  fillRule: {\n    type: String,\n    custom: true,\n    default: \"evenodd\",\n  },\n  className: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n};\n\nconst setup$3 = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n  const {\n    options: interactiveLayerOptions,\n    methods: interactiveLayerMethods,\n  } = setup$2(props);\n\n  const removeLayer = inject(\"removeLayer\");\n\n  const options = {\n    ...layerOptions,\n    ...interactiveLayerOptions,\n    stroke: props.stroke,\n    color: props.color,\n    weight: props.weight,\n    opacity: props.opacity,\n    lineCap: props.lineCap,\n    lineJoin: props.lineJoin,\n    dashArray: props.dashArray,\n    dashOffset: props.dashOffset,\n    fill: props.fill,\n    fillColor: props.fillColor,\n    fillOpacity: props.fillOpacity,\n    fillRule: props.fillRule,\n    className: props.className,\n  };\n  const methods = {\n    ...layerMethods,\n    ...interactiveLayerMethods,\n    setStroke(stroke) {\n      leafletRef.value.setStyle({ stroke });\n    },\n    setColor(color) {\n      leafletRef.value.setStyle({ color });\n    },\n    setWeight(weight) {\n      leafletRef.value.setStyle({ weight });\n    },\n    setOpacity(opacity) {\n      leafletRef.value.setStyle({ opacity });\n    },\n    setLineCap(lineCap) {\n      leafletRef.value.setStyle({ lineCap });\n    },\n    setLineJoin(lineJoin) {\n      leafletRef.value.setStyle({ lineJoin });\n    },\n    setDashArray(dashArray) {\n      leafletRef.value.setStyle({ dashArray });\n    },\n    setDashOffset(dashOffset) {\n      leafletRef.value.setStyle({ dashOffset });\n    },\n    setFill(fill) {\n      leafletRef.value.setStyle({ fill });\n    },\n    setFillColor(fillColor) {\n      leafletRef.value.setStyle({ fillColor });\n    },\n    setFillOpacity(fillOpacity) {\n      leafletRef.value.setStyle({ fillOpacity });\n    },\n    setFillRule(fillRule) {\n      leafletRef.value.setStyle({ fillRule });\n    },\n    setClassName(className) {\n      leafletRef.value.setStyle({ className });\n    },\n  };\n\n  onBeforeUnmount(() => {\n    removeLayer({ leafletObject: leafletRef.value });\n  });\n\n  return { options, methods };\n};\n\nconst props$4 = {\n  ...props$3,\n  latLng: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  /**\n   * Radius of the marker in pixels.\n   */\n  radius: {\n    type: Number,\n    default: null,\n  },\n};\n\nconst setup$4 = (props, leafletRef, context) => {\n  const { options: pathOptions, methods: pathMethods } = setup$3(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...pathOptions,\n    ...props,\n  };\n  const methods = {\n    ...pathMethods,\n    setRadius(radius) {\n      leafletRef.value.setRadius(radius);\n    },\n    setLatLng(latLng) {\n      leafletRef.value.setLatLng(latLng);\n    },\n  };\n\n  return { options, methods };\n};\n\nconst props$5 = {\n  ...props$4,\n  /**\n   * Radius of the circle in meters.\n   */\n  radius: {\n    type: Number,\n    default: null,\n  },\n};\n\nconst setup$5 = (props, leafletRef, context) => {\n  const {\n    options: circleMarkerOptions,\n    methods: circleMarkerMethods,\n  } = setup$4(props, leafletRef, context);\n\n  const options = {\n    ...circleMarkerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...circleMarkerMethods,\n  };\n\n  return { options, methods };\n};\n\n/**\n * Circle component, lets you add and personalize circles on the map\n */\nvar script = {\n  name: \"LCircle\",\n  props: props$5,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$5(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { circle, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = circle(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript.__file = \"src/components/LCircle.vue\";\n\n/**\n * Circle Marker component, lets you add and personalize circle markers on the map\n */\nvar script$1 = {\n  name: \"LCircleMarker\",\n  props: props$4,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$4(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { circleMarker, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = circleMarker(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$1.__file = \"src/components/LCircleMarker.vue\";\n\nconst props$6 = {\n  ...props,\n  position: {\n    type: String,\n    default: \"topright\",\n  },\n};\n\nconst setup$6 = (props, leafletRef) => {\n  const {\n    options: componentOptions,\n    methods: componentMethods,\n  } = setup(props);\n  const options = {\n    ...componentOptions,\n    position: props.position,\n  };\n\n  const methods = {\n    ...componentMethods,\n    setPosition(position) {\n      if (leafletRef.value) {\n        leafletRef.value.setPosition(position);\n      }\n    },\n  };\n\n  onUnmounted(() => {\n    if (leafletRef.value) {\n      leafletRef.value.remove();\n    }\n  });\n\n  return { options, methods };\n};\n\nconst render$1 = (slots) => {\n  if (slots.default) {\n    return h(\"div\", { ref: \"root\" }, slots.default());\n  }\n  return null;\n};\n\nvar script$2 = {\n  name: \"LControl\",\n  props: {\n    ...props$6,\n    disableClickPropagation: {\n      type: Boolean,\n      custom: true,\n      default: true,\n    },\n    disableScrollPropagation: {\n      type: Boolean,\n      custom: true,\n      default: false,\n    },\n  },\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$6(props, leafletRef);\n\n    onMounted(async () => {\n      const { Control, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      const LControl = Control.extend({\n        onAdd() {\n          return root.value;\n        },\n      });\n\n      leafletRef.value = new LControl(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n\n      if (props.disableClickPropagation) {\n        DomEvent.disableClickPropagation(root.value);\n      }\n      if (props.disableScrollPropagation) {\n        DomEvent.disableScrollPropagation(root.value);\n      }\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render$1(this.$slots);\n  },\n};\n\nscript$2.__file = \"src/components/LControl.vue\";\n\nconst props$7 = {\n  ...props$6,\n  prefix: {\n    type: String,\n    default: \"Vue-Leaflet\",\n    custom: true,\n  },\n};\n\nconst setup$7 = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setup$6(\n    props,\n    leafletRef\n  );\n  const options = {\n    ...controlOptions,\n    prefix: props.prefix,\n  };\n\n  const methods = {\n    ...controlMethods,\n    setPrefix(prefix) {\n      leafletRef.value.setPrefix(prefix);\n    },\n  };\n\n  return { options, methods };\n};\n\nvar script$3 = {\n  name: \"LControlAttribution\",\n  props: props$7,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$7(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.attribution(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$3.__file = \"src/components/LControlAttribution.vue\";\n\nconst props$8 = {\n  ...props$6,\n  collapsed: {\n    type: Boolean,\n    default: true,\n  },\n  autoZIndex: {\n    type: Boolean,\n    default: true,\n  },\n  hideSingleBase: {\n    type: Boolean,\n    default: false,\n  },\n  sortLayers: {\n    type: Boolean,\n    default: false,\n  },\n  sortFunction: {\n    type: Function,\n    default: undefined,\n  },\n};\n\nconst setup$8 = (props, leafletRef) => {\n  const { options: controlOptions } = setup$6(props, leafletRef);\n  const options = {\n    ...controlOptions,\n    collapsed: props.collapsed,\n    autoZIndex: props.autoZIndex,\n    hideSingleBase: props.hideSingleBase,\n    sortLayers: props.sortLayers,\n    sortFunction: props.sortFunction,\n  };\n\n  const methods = {\n    addLayer(layer) {\n      if (layer.layerType === \"base\") {\n        leafletRef.value.addBaseLayer(layer.leafletObject, layer.name);\n      } else if (layer.layerType === \"overlay\") {\n        leafletRef.value.addOverlay(layer.leafletObject, layer.name);\n      }\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    },\n  };\n  return { options, methods };\n};\n\nvar script$4 = {\n  name: \"LControlLayers\",\n  props: props$8,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerLayerControl = inject(\"registerLayerControl\");\n\n    const { options, methods } = setup$8(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.layers(null, null, options);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      registerLayerControl({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$4.__file = \"src/components/LControlLayers.vue\";\n\nconst props$9 = {\n  ...props$6,\n  maxWidth: {\n    type: Number,\n    default: 100,\n  },\n  metric: {\n    type: Boolean,\n    default: true,\n  },\n  imperial: {\n    type: Boolean,\n    default: true,\n  },\n  updateWhenIdle: {\n    type: Boolean,\n    default: false,\n  },\n};\n\nconst setup$9 = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setup$6(\n    props,\n    leafletRef\n  );\n  const options = {\n    ...controlOptions,\n    maxWidth: props.maxWidth,\n    metric: props.metric,\n    imperial: props.imperial,\n    updateWhenIdle: props.updateWhenIdle,\n  };\n\n  return { options, methods: controlMethods };\n};\n\nvar script$5 = {\n  name: \"LControlScale\",\n  props: props$9,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$9(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.scale(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$5.__file = \"src/components/LControlScale.vue\";\n\nconst props$a = {\n  ...props$6,\n  zoomInText: {\n    type: String,\n    default: \"+\",\n  },\n  zoomInTitle: {\n    type: String,\n    default: \"Zoom in\",\n  },\n  zoomOutText: {\n    type: String,\n    default: \"-\",\n  },\n  zoomOutTitle: {\n    type: String,\n    default: \"Zoom out\",\n  },\n};\n\nconst setup$a = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setup$6(\n    props,\n    leafletRef\n  );\n  const options = {\n    ...controlOptions,\n    zoomInText: props.zoomInText,\n    zoomInTitle: props.zoomInTitle,\n    zoomOutText: props.zoomOutText,\n    zoomOutTitle: props.zoomOutTitle,\n  };\n\n  return { options, methods: controlMethods };\n};\n\nvar script$6 = {\n  name: \"LControlZoom\",\n  props: props$a,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$a(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.zoom(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$6.__file = \"src/components/LControlZoom.vue\";\n\nconst props$b = {\n  ...props$1,\n};\n\nconst setup$b = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = {\n    ...layerOptions,\n  };\n\n  const methods = {\n    ...layerMethods,\n    addLayer(layer) {\n      leafletRef.value.addLayer(layer.leafletObject);\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    },\n  };\n\n  provide(\"addLayer\", methods.addLayer);\n  provide(\"removeLayer\", methods.removeLayer);\n\n  return { options, methods };\n};\n\nconst props$c = {\n  ...props$b,\n};\n\nconst setup$c = (props, leafletRef) => {\n  const { options: layerOptions, methods: layerGroupMethods } = setup$b(\n    props,\n    leafletRef\n  );\n\n  const options = {\n    ...layerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...layerGroupMethods,\n  };\n\n  return { options, methods };\n};\n\nvar script$7 = {\n  props: props$c,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods, options } = setup$c(props, leafletRef);\n\n    onMounted(async () => {\n      const { featureGroup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = featureGroup(options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$7.__file = \"src/components/LFeatureGroup.vue\";\n\nconst props$d = {\n  ...props$b,\n  geojson: {\n    type: [Object, Array],\n    default: () => ({}),\n  },\n};\n\nconst setup$d = (props, leafletRef) => {\n  const { options: layerOptions, methods: layerGroupMethods } = setup$b(\n    props,\n    leafletRef\n  );\n\n  const options = {\n    ...layerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...layerGroupMethods,\n    setGeojson(newVal) {\n      leafletRef.value.clearLayers();\n      leafletRef.value.addData(newVal);\n    },\n    getGeoJSONData() {\n      return leafletRef.value.toGeoJSON();\n    },\n    getBounds() {\n      return leafletRef.value.getBounds();\n    },\n  };\n\n  return { options, methods };\n};\n\nvar script$8 = {\n  props: props$d,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods, options } = setup$d(props, leafletRef);\n\n    onMounted(async () => {\n      const { geoJSON, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = geoJSON(props.geojson, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$8.__file = \"src/components/LGeoJson.vue\";\n\nconst props$e = {\n  ...props$1,\n  pane: {\n    type: String,\n    default: \"tilePane\",\n  },\n  opacity: {\n    type: Number,\n    custom: false,\n    default: 1.0,\n  },\n  zIndex: {\n    type: Number,\n    default: 1,\n  },\n  tileSize: {\n    type: Number,\n    default: 256,\n  },\n  noWrap: {\n    type: Boolean,\n    default: false,\n  },\n  minZoom: {\n    type: Number,\n    default: 0,\n  },\n  maxZoom: {\n    type: Number,\n    default: undefined,\n  },\n};\n\nconst setup$e = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    pane: props.pane,\n    opacity: props.opacity,\n    zIndex: props.zIndex,\n    tileSize: props.tileSize,\n    noWrap: props.noWrap,\n    minZoom: props.minZoom,\n    maxZoom: props.maxZoom,\n  };\n  return { options, methods: { ...layerMethods } };\n};\n\nvar script$9 = {\n  props: {\n    ...props$e,\n    childRender: {\n      type: Function,\n      required: true,\n    },\n  },\n  setup(props, context) {\n    const leafletRef = ref({});\n    const tileComponents = ref({});\n    const root = ref(null);\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$e(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { GridLayer, DomEvent, DomUtil } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      methods.onUnload = (e) => {\n        const key = leafletRef.value._tileCoordsToKey(e.coords);\n        if (tileComponents[key]) {\n          tileComponents[key].innerHTML = \"\";\n          tileComponents[key] = undefined;\n        }\n      };\n\n      methods.setTileComponent = () => {\n        leafletRef.value.redraw();\n      };\n\n      const GLayer = GridLayer.extend({\n        createTile(coords) {\n          const key = leafletRef.value._tileCoordsToKey(coords);\n          tileComponents[key] = DomUtil.create(\"div\");\n\n          let vNode = h(\n            { setup: props.childRender, props: [\"coords\"] },\n            { coords }\n          );\n          render$3(vNode, tileComponents[key]);\n\n          return tileComponents[key];\n        },\n      });\n\n      leafletRef.value = new GLayer(options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      leafletRef.value.on(\"tileunload\", methods.onUnload);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    onUnmounted(() => {\n      leafletRef.value.off(\"tileunload\", methods.unLoad);\n    });\n\n    return { root, ready, leafletObject: leafletRef };\n  },\n  render() {\n    if (this.ready) {\n      return h(\"div\", { style: { display: \"none\" }, ref: \"root\" });\n    }\n    return null;\n  },\n};\n\nscript$9.__file = \"src/components/LGridLayer.vue\";\n\nconst props$f = {\n  iconUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  iconRetinaUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  iconSize: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  iconAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  popupAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  tooltipAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  shadowUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  shadowRetinaUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  shadowSize: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  shadowAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  bgPos: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  className: {\n    type: String,\n    custom: true,\n    default: \"\",\n  },\n  options: {\n    type: Object,\n    custom: true,\n    default: () => ({}),\n  },\n};\n\n/**\n * Icon component, lets you add and custom icons to the map\n */\nvar script$a = {\n  name: \"LIcon\",\n  props: {\n    ...props$f,\n    ...props,\n  },\n  setup(props, context) {\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const canSetParentHtml = inject(\"canSetParentHtml\");\n    const setParentHtml = inject(\"setParentHtml\");\n    const setIcon = inject(\"setIcon\");\n\n    let onDomEvent;\n    let offDomEvent;\n    let divIcon;\n    let icon;\n    let iconObject = undefined;\n\n    const createIcon = (el, recreationNeeded, htmlSwapNeeded) => {\n      const elHtml = el && el.innerHTML;\n      if (!recreationNeeded) {\n        if (htmlSwapNeeded && iconObject && canSetParentHtml()) {\n          setParentHtml(elHtml);\n        }\n        return;\n      }\n\n      const listeners = remapEvents(context.attrs);\n      if (iconObject) {\n        offDomEvent(iconObject, listeners);\n      }\n\n      const { options: componentOptions } = setup(props);\n      const options = {\n        ...componentOptions,\n        iconUrl: props.iconUrl,\n        iconRetinaUrl: props.iconRetinaUrl,\n        iconSize: props.iconSize,\n        iconAnchor: props.iconAnchor,\n        popupAnchor: props.popupAnchor,\n        tooltipAnchor: props.tooltipAnchor,\n        shadowUrl: props.shadowUrl,\n        shadowRetinaUrl: props.shadowRetinaUrl,\n        shadowSize: props.shadowSize,\n        shadowAnchor: props.shadowAnchor,\n        bgPos: props.bgPos,\n        className: props.className,\n        html: elHtml || props.html,\n      };\n\n      iconObject = options.html ? divIcon(options) : icon(options);\n      onDomEvent(iconObject, listeners);\n      setIcon(iconObject);\n    };\n\n    const scheduleCreateIcon = () => {\n      nextTick(() => createIcon(root.value, true, false));\n    };\n\n    const scheduleHtmlSwap = () => {\n      nextTick(() => createIcon(root.value, false, true));\n    };\n\n    const methods = {\n      setIconUrl: scheduleCreateIcon,\n      setIconRetinaUrl: scheduleCreateIcon,\n      setIconSize: scheduleCreateIcon,\n      setIconAnchor: scheduleCreateIcon,\n      setPopupAnchor: scheduleCreateIcon,\n      setTooltipAnchor: scheduleCreateIcon,\n      setShadowUrl: scheduleCreateIcon,\n      setShadowRetinaUrl: scheduleCreateIcon,\n      setShadowAnchor: scheduleCreateIcon,\n      setBgPos: scheduleCreateIcon,\n      setClassName: scheduleCreateIcon,\n      setHtml: scheduleCreateIcon,\n    };\n\n    onMounted(async () => {\n      const { DomEvent, divIcon: lDivIcon, icon: lIcon } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      onDomEvent = DomEvent.on;\n      offDomEvent = DomEvent.off;\n      divIcon = lDivIcon;\n      icon = lIcon;\n\n      propsBinder(methods, {}, props);\n\n      const observer = new MutationObserver(scheduleHtmlSwap);\n      observer.observe(root.value, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true,\n      });\n      scheduleCreateIcon();\n    });\n\n    return { root };\n  },\n  render() {\n    const content = this.$slots.default ? this.$slots.default() : undefined;\n    return h(\"div\", { ref: \"root\" }, content);\n  },\n};\n\nscript$a.__file = \"src/components/LIcon.vue\";\n\n/**\n * @typedef {import('leaflet/dist/leaflet-src.esm.js').LatLngBounds} LatLngBounds\n */\n\nconst props$g = {\n  ...props$1,\n  url: {\n    type: String,\n    required: true,\n  },\n  bounds: {\n    type: [Array, Object],\n    required: true,\n  },\n  opacity: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  alt: {\n    type: String,\n    default: \"\",\n  },\n  interactive: {\n    type: Boolean,\n    default: false,\n  },\n  crossOrigin: {\n    type: Boolean,\n    default: false,\n  },\n  errorOverlayUrl: {\n    type: String,\n    custom: true,\n    default: \"\",\n  },\n  zIndex: {\n    type: Number,\n    custom: true,\n    default: 1,\n  },\n  className: {\n    type: String,\n    default: \"\",\n  },\n};\n\nconst setup$f = (setupProps, LeafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    setupProps,\n    LeafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    ...setupProps,\n  };\n\n  const methods = {\n    ...layerMethods,\n    /**\n     * Sets the opacity of the overlay.\n     * @param {number} opacity\n     */\n    setOpacity(opacity) {\n      return LeafletRef.value.setOpacity(opacity);\n    },\n    /**\n     * Changes the URL of the image.\n     * @param {string} url\n     */\n    setUrl(url) {\n      return LeafletRef.value.setUrl(url);\n    },\n    /**\n     * Update the bounds that this ImageOverlay covers\n     * @param {LatLngBounds | Array<Array<number>>} bounds\n     */\n    setBounds(bounds) {\n      return LeafletRef.value.setBounds(bounds);\n    },\n    /**\n     * Get the bounds that this ImageOverlay covers\n     * @returns {LatLngBounds}\n     */\n    getBounds() {\n      return LeafletRef.value.getBounds();\n    },\n    /**\n     * Returns the instance of HTMLImageElement used by this overlay.\n     * @returns {HTMLElement}\n     */\n    getElement() {\n      return LeafletRef.value.getElement();\n    },\n    /**\n     * Brings the layer to the top of all overlays.\n     */\n    bringToFront() {\n      return LeafletRef.value.bringToFront();\n    },\n    /**\n     * Brings the layer to the bottom of all overlays.\n     */\n    bringToBack() {\n      return LeafletRef.value.bringToBack();\n    },\n    /**\n     * Changes the zIndex of the image overlay.\n     * @param {number} zIndex\n     */\n    setZIndex(zIndex) {\n      return LeafletRef.value.setZIndex(zIndex);\n    },\n  };\n\n  return { options, methods };\n};\n\n/**\n * ImageOverlay component, render a plain image instead of a geospatial map.\n */\nvar script$b = {\n  name: \"LImageOverlay\",\n  props: props$g,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$f(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { imageOverlay, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = imageOverlay(props.url, props.bounds, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$b.__file = \"src/components/LImageOverlay.vue\";\n\nvar script$c = {\n  props: props$b,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods } = setup$b(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { layerGroup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = layerGroup(props.options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$c.__file = \"src/components/LLayerGroup.vue\";\n\nvar script$d = {\n  emits: [\"ready\", \"update:zoom\", \"update:center\", \"update:bounds\"],\n  props: {\n    ...props,\n    /**\n     * The center of the map, supports .sync modifier\n     */\n    center: {\n      type: [Object, Array],\n      default: () => [0, 0],\n    },\n    /**\n     * The bounds of the map, supports .sync modifier\n     */\n    bounds: {\n      type: [Array, Object],\n      default: undefined,\n    },\n    /**\n     * The max bounds of the map\n     */\n    maxBounds: {\n      type: [Array, Object],\n      default: undefined,\n    },\n    /**\n     * The zoom of the map, supports .sync modifier\n     */\n    zoom: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * The minZoom of the map\n     */\n    minZoom: {\n      type: Number,\n      default: undefined,\n    },\n    /**\n     * The maxZoom of the map\n     */\n    maxZoom: {\n      type: Number,\n      default: undefined,\n    },\n    /**\n     * The paddingBottomRight of the map\n     */\n    paddingBottomRight: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The paddingTopLeft of the map\n     */\n    paddingTopLeft: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The padding of the map\n     */\n    padding: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The worldCopyJump option for the map\n     */\n    worldCopyJump: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The CRS to use for the map. Can be an object that defines a coordinate reference\n     * system for projecting geographical points into screen coordinates and back\n     * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string\n     * name identifying one of Leaflet's defined CRSs, such as \"EPSG4326\".\n     */\n    crs: {\n      type: [String, Object],\n      default: \"EPSG3857\",\n    },\n    maxBoundsViscosity: {\n      type: Number,\n      default: undefined,\n    },\n    inertia: {\n      type: Boolean,\n      default: undefined,\n    },\n    inertiaDeceleration: {\n      type: Number,\n      default: undefined,\n    },\n    inertiaMaxSpeed: {\n      type: Number,\n      default: undefined,\n    },\n    easeLinearity: {\n      type: Number,\n      default: undefined,\n    },\n    zoomAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    zoomAnimationThreshold: {\n      type: Number,\n      default: undefined,\n    },\n    fadeAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    markerZoomAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    noBlockingAnimations: {\n      type: Boolean,\n      default: false,\n    },\n    useGlobalLeaflet: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props, context) {\n    const root = ref(null);\n    const blueprint = reactive({\n      ready: false,\n      leafletRef: {},\n      layersToAdd: [],\n      layersInControl: [],\n    });\n    const { options: componentOptions } = setup(props);\n    const options = {\n      ...componentOptions,\n      minZoom: props.minZoom,\n      maxZoom: props.maxZoom,\n      maxBounds: props.maxBounds,\n      maxBoundsViscosity: props.maxBoundsViscosity,\n      worldCopyJump: props.worldCopyJump,\n      crs: props.crs,\n      center: props.center,\n      zoom: props.zoom,\n      inertia: props.inertia,\n      inertiaDeceleration: props.inertiaDeceleration,\n      inertiaMaxSpeed: props.inertiaMaxSpeed,\n      easeLinearity: props.easeLinearity,\n      zoomAnimation: props.zoomAnimation,\n      zoomAnimationThreshold: props.zoomAnimationThreshold,\n      fadeAnimation: props.fadeAnimation,\n      markerZoomAnimation: props.markerZoomAnimation,\n    };\n\n    const addLayer = provideLeafletWrapper(\"addLayer\");\n    const removeLayer = provideLeafletWrapper(\"removeLayer\");\n    const registerControl = provideLeafletWrapper(\"registerControl\");\n    const registerLayerControl = provideLeafletWrapper(\"registerLayerControl\");\n    provide(GLOBAL_LEAFLET_OPT, props.useGlobalLeaflet);\n\n    const eventHandlers = {\n      moveEndHandler() {\n        /**\n         * Triggers when zoom is updated\n         * @type {number,string}\n         */\n        context.emit(\"update:zoom\", blueprint.leafletRef.getZoom());\n        /**\n         * Triggers when center is updated\n         * @type {object,array}\n         */\n        context.emit(\"update:center\", blueprint.leafletRef.getCenter());\n\n        /**\n         * Triggers when bounds are updated\n         * @type {object}\n         */\n        context.emit(\"update:bounds\", blueprint.leafletRef.getBounds());\n      },\n      overlayAddHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(true);\n        }\n      },\n      overlayRemoveHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(false);\n        }\n      },\n    };\n\n    onMounted(async () => {\n      if (props.useGlobalLeaflet) {\n        WINDOW_OR_GLOBAL.L = WINDOW_OR_GLOBAL.L || (await import('leaflet'));\n      }\n      const {\n        map,\n        CRS,\n        Icon,\n        latLngBounds,\n        latLng,\n        DomEvent,\n      } = props.useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      try {\n        options.beforeMapMount && (await options.beforeMapMount());\n      } catch (error) {\n        console.error(\n          `The following error occurred running the provided beforeMapMount hook ${error.message}`\n        );\n      }\n\n      await resetWebpackIcon(Icon);\n\n      const optionsCrs =\n        typeof options.crs == \"string\" ? CRS[options.crs] : options.crs;\n      options.crs = optionsCrs || CRS.EPSG3857;\n\n      const methods = {\n        addLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd.push(layer);\n            } else {\n              const exist = blueprint.layersInControl.find(\n                (l) =>\n                  l.leafletObject._leaflet_id ===\n                  layer.leafletObject._leaflet_id\n              );\n              if (!exist) {\n                blueprint.layerControl.addLayer(layer);\n                blueprint.layersInControl.push(layer);\n              }\n            }\n          }\n          if (layer.visible !== false) {\n            blueprint.leafletRef.addLayer(layer.leafletObject);\n          }\n        },\n        removeLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd = blueprint.layersToAdd.filter(\n                (l) => l.name !== layer.name\n              );\n            } else {\n              blueprint.layerControl.removeLayer(layer.leafletObject);\n              blueprint.layersInControl = blueprint.layersInControl.filter(\n                (l) =>\n                  l.leafletObject._leaflet_id !==\n                  layer.leafletObject._leaflet_id\n              );\n            }\n          }\n          blueprint.leafletRef.removeLayer(layer.leafletObject);\n        },\n\n        registerLayerControl(lControlLayer) {\n          blueprint.layerControl = lControlLayer;\n          blueprint.layersToAdd.forEach((layer) => {\n            blueprint.layerControl.addLayer(layer);\n          });\n          blueprint.layersToAdd = [];\n\n          registerControl(lControlLayer);\n        },\n\n        registerControl(lControl) {\n          blueprint.leafletRef.addControl(lControl.leafletObject);\n        },\n\n        setZoom(newVal) {\n          const zoom = blueprint.leafletRef.getZoom();\n          if (newVal !== zoom) {\n            blueprint.leafletRef.setZoom(newVal, {\n              animate: props.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n\n        setPaddingBottomRight(newVal) {\n          blueprint.paddingBottomRight = newVal;\n        },\n        setPaddingTopLeft(newVal) {\n          blueprint.paddingTopLeft = newVal;\n        },\n        setPadding(newVal) {\n          blueprint.padding = newVal;\n        },\n        setCrs(newVal) {\n          const prevBounds = blueprint.leafletRef.getBounds();\n          blueprint.leafletRef.options.crs = newVal;\n          blueprint.leafletRef.fitBounds(prevBounds, {\n            animate: false,\n            padding: [0, 0],\n          });\n        },\n        fitBounds(bounds) {\n          blueprint.leafletRef.fitBounds(bounds, {\n            animate: this.noBlockingAnimations ? false : null,\n          });\n        },\n        setBounds(newVal) {\n          if (!newVal) {\n            return;\n          }\n          const newBounds = latLngBounds(newVal);\n          if (!newBounds.isValid()) {\n            return;\n          }\n          const oldBounds =\n            blueprint.lastSetBounds || blueprint.leafletRef.getBounds();\n          const boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals\n          if (boundsChanged) {\n            blueprint.lastSetBounds = newBounds;\n            blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);\n          }\n        },\n\n        setCenter(newVal) {\n          if (newVal == null) {\n            return;\n          }\n          const newCenter = latLng(newVal);\n          const oldCenter =\n            blueprint.lastSetCenter || blueprint.leafletRef.getCenter();\n          if (\n            oldCenter.lat !== newCenter.lat ||\n            oldCenter.lng !== newCenter.lng\n          ) {\n            blueprint.lastSetCenter = newCenter;\n            blueprint.leafletRef.panTo(newCenter, {\n              animate: this.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n      };\n\n      updateLeafletWrapper(addLayer, methods.addLayer);\n      updateLeafletWrapper(removeLayer, methods.removeLayer);\n      updateLeafletWrapper(registerControl, methods.registerControl);\n      updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);\n\n      blueprint.leafletRef = map(root.value, options);\n\n      propsBinder(methods, blueprint.leafletRef, props);\n      const listeners = remapEvents(context.attrs);\n\n      blueprint.leafletRef.on(\n        \"moveend\",\n        debounce(eventHandlers.moveEndHandler, 100)\n      );\n      blueprint.leafletRef.on(\"overlayadd\", eventHandlers.overlayAddHandler);\n      blueprint.leafletRef.on(\n        \"overlayremove\",\n        eventHandlers.overlayRemoveHandler\n      );\n      DomEvent.on(blueprint.leafletRef, listeners);\n      blueprint.ready = true;\n      nextTick(() => context.emit(\"ready\", blueprint.leafletRef));\n    });\n\n    onBeforeUnmount(() => {\n      if (blueprint.leafletRef) {\n        blueprint.leafletRef.remove();\n      }\n    });\n\n    const leafletObject = computed(() => blueprint.leafletRef);\n    const ready = computed(() => blueprint.ready);\n    return { root, ready, leafletObject };\n  },\n  render() {\n    return h(\n      \"div\",\n      { style: { width: \"100%\", height: \"100%\" }, ref: \"root\" },\n      this.ready ? this.$slots.default() : {}\n    );\n  },\n};\n\nscript$d.__file = \"src/components/LMap.vue\";\n\nconst props$h = {\n  ...props$1,\n  pane: {\n    type: String,\n    default: \"markerPane\",\n  },\n  draggable: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n  latLng: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  icon: {\n    type: [Object],\n    default: () => undefined,\n    custom: false,\n  },\n  zIndexOffset: {\n    type: Number,\n    custom: false,\n    default: null,\n  },\n};\n\nconst setup$g = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...layerMethods,\n    setDraggable(value) {\n      if (leafletRef.value.dragging) {\n        value\n          ? leafletRef.value.dragging.enable()\n          : leafletRef.value.dragging.disable();\n      }\n    },\n    latLngSync(event) {\n      context.emit(\"update:latLng\", event.latlng);\n      context.emit(\"update:lat-lng\", event.latlng);\n    },\n    setLatLng(newVal) {\n      if (newVal == null) {\n        return;\n      }\n\n      if (leafletRef.value) {\n        const oldLatLng = leafletRef.value.getLatLng();\n        if (!oldLatLng || !oldLatLng.equals(newVal)) {\n          leafletRef.value.setLatLng(newVal);\n        }\n      }\n    },\n  };\n  return { options, methods };\n};\n\n/**\n * Marker component, lets you add and personalize markers on the map\n */\nvar script$e = {\n  name: \"LMarker\",\n  props: props$h,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    provide(\"canSetParentHtml\", () => !!leafletRef.value.getElement());\n    provide(\n      \"setParentHtml\",\n      (html) => (leafletRef.value.getElement().innerHTML = html)\n    );\n    provide(\n      \"setIcon\",\n      (newIcon) => leafletRef.value.setIcon && leafletRef.value.setIcon(newIcon)\n    );\n    const { options, methods } = setup$g(props, leafletRef, context);\n    if (options.icon === undefined) {\n      // If the options objection has a property named 'icon', then Leaflet will overwrite\n      // the default icon with it for the marker, _even if it is undefined_.\n      // This leads to the issue discussed in https://github.com/vue-leaflet/vue-leaflet/issues/130\n      delete options.icon;\n    }\n\n    onMounted(async () => {\n      const { marker, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = marker(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      leafletRef.value.on(\"move\", debounce(methods.latLngSync, 100));\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$e.__file = \"src/components/LMarker.vue\";\n\nconst props$i = {\n  ...props$3,\n  latLngs: {\n    type: Array,\n    default: () => [],\n  },\n  smoothFactor: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  noClip: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n};\n\nconst setup$h = (props, leafletRef, context) => {\n  const { options: pathOptions, methods: pathMethods } = setup$3(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...pathOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...pathMethods,\n    setSmoothFactor(smoothFactor) {\n      leafletRef.value.setStyle({ smoothFactor });\n    },\n    setNoClip(noClip) {\n      leafletRef.value.setStyle({ noClip });\n    },\n    addLatLng(latLng) {\n      leafletRef.value.addLatLng(latLng);\n    },\n  };\n  return { options, methods };\n};\n\nconst props$j = {\n  ...props$i,\n};\n\nconst setup$i = (props, leafletRef, context) => {\n  const { options: polylineOptions, methods: polylineMethods } = setup$h(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...polylineOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...polylineMethods,\n    toGeoJSON(precision) {\n      return leafletRef.value.toGeoJSON(precision);\n    },\n  };\n\n  return { options, methods };\n};\n\n/**\n * Polygon component, lets you add and customize polygon regions on the map\n */\nvar script$f = {\n  name: \"LPolygon\",\n  props: props$j,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$i(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { polygon, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = polygon(props.latLngs, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$f.__file = \"src/components/LPolygon.vue\";\n\n/**\n * Polyline component, lets you add and personalize polylines on the map\n */\nvar script$g = {\n  name: \"LPolyline\",\n  props: props$i,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$h(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { polyline, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = polyline(props.latLngs, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$g.__file = \"src/components/LPolyline.vue\";\n\nconst props$k = {\n  ...props,\n  content: {\n    type: String,\n    default: null,\n  },\n};\n\nconst setup$j = (props, leafletRef) => {\n  const { options, methods: componentMethods } = setup(props);\n  const methods = {\n    ...componentMethods,\n    setContent(newVal) {\n      if (leafletRef.value && newVal !== null && newVal !== undefined) {\n        leafletRef.value.setContent(newVal);\n      }\n    },\n  };\n  return { options, methods };\n};\n\nconst render$2 = (slots) => {\n  if (slots.default) {\n    return h(\"div\", { ref: \"root\" }, slots.default());\n  }\n  return null;\n};\n\nconst props$l = {\n  ...props$k,\n  latLng: {\n    type: [Object, Array],\n    default: () => [],\n  },\n};\n\nconst setup$k = (props, leafletRef) => {\n  const { options, methods } = setup$j(props, leafletRef);\n  const unbindPopup = inject(\"unbindPopup\");\n\n  onBeforeUnmount(() => {\n    unbindPopup();\n  });\n\n  return { options, methods };\n};\n\n/**\n * Display a popup on the map\n */\nvar script$h = {\n  name: \"LPopup\",\n  props: props$l,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const bindPopup = inject(\"bindPopup\");\n\n    const { options, methods } = setup$k(props, leafletRef);\n\n    onMounted(async () => {\n      const { popup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = popup(options);\n\n      if (props.latLng !== undefined) {\n        leafletRef.value.setLatLng(props.latLng);\n      }\n\n      propsBinder(methods, leafletRef.value, props);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.setContent(props.content || root.value);\n      bindPopup({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render$2(this.$slots);\n  },\n};\n\nscript$h.__file = \"src/components/LPopup.vue\";\n\nconst props$m = {\n  ...props$j,\n  bounds: {\n    type: Array,\n    default: undefined,\n  },\n};\n\nconst setup$l = (props, leafletRef, context) => {\n  const { options: polygonOptions, methods: polygonMethods } = setup$i(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...polygonOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...polygonMethods,\n    setBounds(latLngBounds) {\n      leafletRef.value.setBounds(latLngBounds);\n    },\n    setLatLngs(latLngs) {\n      // Calling setLatLngs on a Leaflet rectangle will convert it\n      // to a polygon. So instead, we call setBounds here to ensure\n      // that the rectangle remains a rectangle, defined by the\n      // bounds of the points in the latLngs array.\n      leafletRef.value.setBounds(latLngs);\n    },\n  };\n\n  return { options, methods };\n};\n\n/**\n * Rectangle component, lets you add and customize rectangular regions on the map\n */\nvar script$i = {\n  name: \"LRectangle\",\n  props: props$m,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$l(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { rectangle, latLngBounds, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      const bounds =\n        props.bounds && props.bounds.length\n          ? latLngBounds(props.bounds)\n          : latLngBounds(props.latLngs);\n      leafletRef.value = rectangle(bounds, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$i.__file = \"src/components/LRectangle.vue\";\n\nconst props$n = {\n  ...props$e,\n  tms: {\n    type: Boolean,\n    default: false,\n  },\n  subdomains: {\n    type: String,\n    default: \"abc\",\n  },\n  detectRetina: {\n    type: Boolean,\n    default: false,\n  },\n  url: {\n    type: String,\n    default: null,\n  },\n};\n\nconst setup$m = (props, leafletRef) => {\n  const {\n    options: gridLayerOptions,\n    methods: gridLayerMethods,\n  } = setup$e(props, leafletRef);\n  const options = {\n    ...gridLayerOptions,\n    tms: props.tms,\n    subdomains: props.subdomains,\n    detectRetina: props.detectRetina,\n  };\n  return {\n    options,\n    methods: {\n      ...gridLayerMethods,\n    },\n  };\n};\n\nvar script$j = {\n  props: props$n,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$m(props, leafletRef);\n\n    onMounted(async () => {\n      const { tileLayer, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = tileLayer(props.url, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { leafletObject: leafletRef };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$j.__file = \"src/components/LTileLayer.vue\";\n\nconst props$o = {\n  ...props$k,\n};\n\nconst setup$n = (props, leafletRef) => {\n  const { options, methods } = setup$j(props, leafletRef);\n  const unbindTooltip = inject(\"unbindTooltip\");\n\n  onBeforeUnmount(() => {\n    unbindTooltip();\n  });\n\n  return { options, methods };\n};\n\n/**\n * Display a tooltip on the map\n */\nvar script$k = {\n  name: \"LTooltip\",\n  props: props$o,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const bindTooltip = inject(\"bindTooltip\");\n\n    const { options, methods } = setup$n(props, leafletRef);\n\n    onMounted(async () => {\n      const { tooltip, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = tooltip(options);\n\n      propsBinder(methods, leafletRef.value, props);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.setContent(props.content || root.value);\n      bindTooltip({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render$2(this.$slots);\n  },\n};\n\nscript$k.__file = \"src/components/LTooltip.vue\";\n\nconst props$p = {\n  ...props$n,\n  baseUrl: {\n    type: String,\n    default: null,\n    required: true,\n  },\n  layers: {\n    type: String,\n    default: \"\",\n  },\n  styles: {\n    type: String,\n    default: \"\",\n  },\n  format: {\n    type: String,\n    default: \"image/jpeg\",\n  },\n  transparent: {\n    type: Boolean,\n    custom: false,\n  },\n  version: {\n    type: String,\n    default: \"1.1.1\",\n  },\n  crs: {\n    default: null,\n  },\n  upperCase: {\n    type: Boolean,\n    default: false,\n  },\n};\n\nconst setup$o = (props, leafletRef) => {\n  const {\n    options: tileLayerOptions,\n    methods: tileLayerMethods,\n  } = setup$m(props, leafletRef);\n  const options = {\n    ...tileLayerOptions,\n    layers: props.layers,\n    styles: props.styles,\n    format: props.format,\n    transparent: props.transparent,\n    version: props.version,\n    crs: props.crs,\n    upperCase: props.upperCase,\n  };\n  return {\n    options,\n    methods: {\n      ...tileLayerMethods,\n    },\n  };\n};\n\nvar script$l = {\n  props: props$p,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$o(props, leafletRef);\n\n    onMounted(async () => {\n      const { tileLayer, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = tileLayer.wms(props.baseUrl, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$l.__file = \"src/components/LWmsTileLayer.vue\";\n\nexport { script as LCircle, script$1 as LCircleMarker, script$2 as LControl, script$3 as LControlAttribution, script$4 as LControlLayers, script$5 as LControlScale, script$6 as LControlZoom, script$7 as LFeatureGroup, script$8 as LGeoJson, script$9 as LGridLayer, script$a as LIcon, script$b as LImageOverlay, script$c as LLayerGroup, script$d as LMap, script$e as LMarker, script$f as LPolygon, script$g as LPolyline, script$h as LPopup, script$i as LRectangle, script$j as LTileLayer, script$k as LTooltip, script$l as LWmsTileLayer };\n//# sourceMappingURL=vue-leaflet.esm.js.map\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n","<template>\n  <l-map ref=\"map\" style=\"height: 50vh\" :zoom=\"zoom\" :center=\"center\">\n    <l-tile-layer :url=\"url\" :attribution=\"attribution\" />\n  </l-map>\n  <button class=\"btn btn-primary\" @click.prevent=\"makeCityBoundary\">\n    縣市邊界圖\n  </button>\n  <br />\n  <input type=\"checkbox\" id=\"r1\" v-model=\"is_showBoundary\" @change=\"change()\" />\n  <label for=\"r1\" style=\"color: #f2f2f2\"><span></span>縣市邊界圖</label>\n  <br />\n  <input type=\"checkbox\" id=\"r2\" name=\"rr\" />\n  <label for=\"r2\" style=\"color: #f2f2f2\"><span></span>Radio Button 2</label>\n</template>\n<script>\n// 參考: https://ithelp.ithome.com.tw/articles/10230107?sc=pt\n// npm install @vue-leaflet/vue-leaflet\n// npm install leaflet\nimport 'leaflet/dist/leaflet.css';\nimport { LMap, LTileLayer } from '@vue-leaflet/vue-leaflet'; // LGeoJson\nimport axios from 'axios';\n\nexport default {\n  components: {\n    LMap,\n    LTileLayer,\n  },\n  data() {\n    return {\n      zoom: 16,\n      center: [22.612961, 120.304167],\n      url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n      attribution:\n        '© <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors',\n      is_showBoundary: false,\n    };\n  },\n  created() {\n    this.getCityBoundaryjson();\n  },\n  mounted() {},\n  methods: {\n    async beforeMount() {\n      // HERE is where to load Leaflet components!\n      // const { circleMarker } = await import('leaflet/dist/leaflet-src.esm');\n\n      // And now the Leaflet circleMarker function can be used by the options:\n      // this.geojsonOptions.pointToLayer =\n      //   (feature, latLng) => circleMarker(latLng, { radius: 8 });\n      this.mapIsReady = true;\n    },\n    makeCityBoundary() {\n      this.is_showBoundary = true;\n    },\n    getCityBoundaryjson() {\n      axios\n        .get(\n          'https://raw.githubusercontent.com/huang-hua1212/taiwan.json/main/taiwan.json',\n        )\n        .then((res) => {\n          this.geojson.features = res.data.features;\n        });\n    },\n  },\n};\n</script>\n","function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nexport default function _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}","import { render } from \"./Map.vue?vue&type=template&id=434ec1ec\"\nimport script from \"./Map.vue?vue&type=script&lang=js\"\nexport * from \"./Map.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"C:\\\\Users\\\\hua_8\\\\Desktop\\\\VUE_CLI\\\\music-streaming\\\\node_modules\\\\@vue\\\\cli-service\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"sourceRoot":""}